
{
    init: function(elevators, floors) {

        var turnPunish = 0;
        var floor0Fix = 0;
        //爬楼时间成本
        var distanceCoseRate = 0.1;
        var checkinRate=10;
        var checkoutRate=10;
        var outFirst=true;

        for (var i = 0; i < elevators.length; i++) {


            var elevator = elevators[i]; // Let's use the first elevator
            elevator.stress = 0;

            elevator.on("idle", function () {
                // let's go to all the floors (or did we forget one?)
                this.goToFloor(getBestFloor(elevators.indexOf(this)), true); 
            });

            elevator.on("passing_floor", function (floorNum, direction) {
                //this.goToFloor(getBestFloor(elevators.indexOf(this)), true);
            });

            elevator.on("stopped_at_floor", function (floorNum) {
                // if(this.farFloor==this.currentFloor())
                // {
                //     if(this.planDirection="up")this.planDirection="down";
                //     else this.planDirection="up";

                //     console.log("切换方向")

                // }

                this.goToFloor(getBestFloor(elevators.indexOf(this)), true);
            })

            elevator.on("floor_button_pressed", function (floorNum) {
                this.goToFloor(getBestFloor(elevators.indexOf(this)), true);
            });

        }



        getBestFloor = function (elevatorNum) {
            floorScores = []

            bestFloorNum = 0;

            var elevator = elevators[elevatorNum];

            farFloor = elevator.currentFloor();

            console.log("===============");
            console.log("开始计算" + elevatorNum + "号电梯");
            //console.log("电梯按下的楼层有",elevator.getPressedFloors());

            //获取最远楼层和最佳楼层
            for (var j = 0; j < floors.length; j++) {
                floorScores[j] = calcFloorScore(j, elevatorNum);

                if (j == 0) floorScores[j] + floor0Fix;

                if (floorScores[bestFloorNum] < floorScores[j])
                    bestFloorNum = j;


                if (elevator.loadFactor() ==0) {
                    elevator.planDirection = "any"
                    farFloor = bestFloorNum
                }
                else {
                    if (floorScores[j] > 0 && j > farFloor && elevator.planDirection == "up")
                        farFloor = j;

                    if (floorScores[j] < 0 && j < farFloor && elevator.planDirection == "down")
                        farFloor = j;
                }

            }



            if (bestFloorNum == elevator.currentFloor()) {
                elevator.stress+=2;
                console.log("压力增加", elevator.stress);
            }
            var manSpace = Math.floor((1 - elevator.loadFactor()) * elevator.maxPassengerCount());
            if (manSpace > elevator.maxPassengerCount() * 0.5) {
                if (elevator.stress > 0)
                    elevator.stress--;
            }

            // if(floorScores[bestFloorNum]<=0)
            // {
            //     bestFloorNum=Math.floor(Math.random()*floors.length);
            // }


            if (elevator.loadFactor() == 0) {
                if (bestFloorNum > elevator.currentFloor())
                    elevator.planDirection = "up"
                if (bestFloorNum < elevator.currentFloor())
                    elevator.planDirection = "down"
            }

            var farDistance = farFloor - elevator.currentFloor();

            console.log("楼层评分", floorScores);
            console.log("方向选择", elevator.planDirection);
            console.log("最远楼层", farFloor);
            console.log("最佳楼层", bestFloorNum);
            console.log("剩余距离", farDistance);


            //console.log("elevator.planDirection",elevator.planDirection)
            //console.log(elevator);

            //elevator.goingUpIndicator(elevator.planDirection!="down" || elevator.currentFloor()==0);
            //elevator.goingDownIndicator(elevator.planDirection!="up" || elevator.currentFloor()==floors.length-1);
            //上人的最佳策略：一楼优先，尽量满载，
            elevator.goingUpIndicator(farDistance >= 0 || elevator.loadFactor() * farDistance < 2 || elevator.planDirection != "down")
            elevator.goingDownIndicator(farDistance <= 0 || elevator.loadFactor() * farDistance < 2 || elevator.planDirection != "up")


            return bestFloorNum;
        }

        //评分思路，空仓载人优先，满仓送人优先，近距离优先
        calcFloorScore = function (floorNum, elevatorNum) {
            var score = 0;
            var elevator = elevators[elevatorNum];
            //console.log(elevators);
            var floor = floors[floorNum];
            var distance = floorNum - elevator.currentFloor();
            var manSpace = Math.floor((1 - elevator.loadFactor()) * elevator.maxPassengerCount());
            //楼层成本
            if (elevator.loadFactor() > 0.1)
                score -= Math.abs(distance) * distanceCoseRate;
            var pf = elevator.getPressedFloors();



            if (pf.indexOf(floorNum) >= 0) {
                score += checkoutRate*elevator.loadFactor();
                console.log("去", floorNum, "层送客");
            }

            //如果该楼层有人等电梯，且有位置，且不是送客优先，则考虑搭载
            if ((floor.buttonStates.up != "" || floor.buttonStates.down != "") && manSpace > 0  && !(outFirst && pf.length>0 )) {

                if (floor.buttonStates.up != "" && elevator.planDirection != "down" ) {
                    score += checkoutRate*(0.9-elevator.loadFactor());
                }
                else if (floor.buttonStates.down != "" && elevator.planDirection != "up") {
                    score += checkoutRate*(0.9-elevator.loadFactor());
                }
                else {
                    //score+=floors.length*0.5;
                }
                console.log("去", floorNum, "层接客，评分", score);

            }

            //回头惩罚机制
            if (floorNum > elevator.currentFloor() && elevator.planDirection == "down") {
                score -= turnPunish;
            }

            if (floorNum < elevator.currentFloor() && elevator.planDirection == "up") {
                score -= turnPunish;
            }

            if (floorNum == elevator.currentFloor()) {
                score -= elevator.stress;
                //console.log(floorNum,"层遇到阻力，扣",elevator.stress,"分，最终分",score)
            }


            return score;
        }

        var floor = floors[0];
        floor.on("up_button_pressed", function () {

        });

        floor.on("down_button_pressed", function () {
            // Maybe tell an elevator to go to this floor?
        });



    },
    update: function(dt, elevators, floors) {
        // We normally don't need to do anything here
    }
}